/**
 * Уявимо що ми маємо два числа 0.1 і 0.9999 і ми хочемо перевірити чи
 * вони однакові. Або якщо числа 25.00000001 і 25 і так далі. Бо для цілих чисел проблеми немає (окрім переповнення),
 * але от для дробових є проблема неможливості повного представлення у двійковому коді і як наслідок округлення. Тож
 * якщо ми будемо порівнювати через == то очевидно отримаємо false, навіть якщо числа дуже близькі
 * Для цього є алгоритм який описав Кнут.
 *
 * Суть алгоритму в тому, що ми спочатку знаходимо найбільше число по модулю між a і b,
 * а потім беремо від нього відсоток який вказали, до прикладу ми вважаємо що числа
 * будуть однаковими якщо розбіжність між ними 1%, тоді relEpsilon буде 0.01. Тож беремо
 * цей відсоток від найбільшого по модулю між a і b.
 * І потім порівнюємо цей значення з різницею a і b по модулю. Якщо різниця менше ніж вказаний
 * відсоток від найбільшого числа то числа рівні, інакше різниця між a і b занадто велика
 *
 * Якщо ми порівнюємо дуже малі числа 0.12345678 і 0.12345679 то ми можемо взяти більш
 * жорсткий відсоток для порівняння, до прикладу 0.001% (це буде 0.00001), а якщо у нас
 * будуть дуже великі числа, то можливо тоді ми будемо зацікавлені у менш жорстокому
 * відсотку і візьмемо до прикладу 0.1% (0.001) коли мова йде трильиони
 * 
 * Але у цього алгоритму є недолік при роботі зі значеннями, що близькі до 0,
 * покращений алгоритм знаходиться у файлі approximatelyEqualAbsRel 
 */

function approximatelyEqualRel(a, b, relEpsilon) {
  const moduleMax = Math.max(Math.abs(a), Math.abs(b));
  return Math.abs(a - b) <= moduleMax * relEpsilon;
}

const a = 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1;
console.log(a == 1); // false
console.log(approximatelyEqualRel(a, 1, 1e-8)); // true

/**
 * Але є проблема, якщо a = -0.000123, b=0, relEpsilon=0.01 (1%), в цьому випадку працювати не буде, оскільки
 * moduleMax = 0.000123
 * moduleMax * relEpsilon = 0,0000012
 * Math.abs(a - b) = 0.000123
 * 0.000123 НЕ МЕНШЕ 0.0000012, тож отримуємо false 
 * 
 * Ця логіка ламається, коли числа близькі до нуля, тому що відносна похибка стає занадто малою,
 * щоб покрити навіть найменші фактичні відмінності. І тому навіть якщо розбіжність буде в край малою,
 * бо виникла через округлення дробових чисел це поверне результат порівняння false
 */

console.log(approximatelyEqualRel(-0.000123, 0, 0.01)); // false
