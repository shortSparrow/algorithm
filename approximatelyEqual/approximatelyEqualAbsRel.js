/**
 * Уявимо що ми маємо два числа 0.1 і 0.9999 і ми хочемо перевірити чи
 * вони однакові. Або якщо числа 25.00000001 і 25 і так далі. Бо для цілих чисел проблеми немає (окрім переповнення),
 * але от для дробових є проблема неможливості повного представлення у двійковому коді і як наслідок округлення. Тож
 * якщо ми будемо порівнювати через == то очевидно отримаємо false, навіть якщо числа дуже близькі
 * Для цього є алгоритм який описав Кнут.
 *
 * Суть алгоритму в тому, що ми спочатку знаходимо найбільше число по модулю між a і b,
 * а потім беремо від нього відсоток який вказали, до прикладу ми вважаємо що числа
 * будуть однаковими якщо розбіжність між ними 1%, тоді relEpsilon буде 0.01. Тож беремо
 * цей відсоток від найбільшого по модулю між a і b.
 * І потім порівнюємо цей значення з різницею a і b по модулю. Якщо різниця менше ніж вказаний
 * відсоток від найбільшого числа то числа рівні, інакше різниця між a і b занадто велика
 *
 * Якщо ми порівнюємо дуже малі числа 0.12345678 і 0.12345679 то ми можемо взяти більш
 * жорсткий відсоток для порівняння, до прикладу 0.001% (це буде 0.00001), а якщо у нас
 * будуть дуже великі числа, то можливо тоді ми будемо зацікавлені у менш жорстокому
 * відсотку і візьмемо до прикладу 0.1% (0.001) коли мова йде трильиони
 * 
 * Це покращений варіант, який також працює з вкрай малими числам,  бо має додатковий параметр
 * absEpsilon - це абсолютне значення допустимої похибки. Якщо різниця між a і b по модулю
 * будуть менші ніж абсолютна похибка то числа рівні, якщо ж ні, то запускаємо стандартний
 * алгоритм Кнута 
 */

function approximatelyEqualRel(a, b, relEpsilon) {
  const moduleMax = Math.max(Math.abs(a), Math.abs(b));
  return Math.abs(a - b) <= moduleMax * relEpsilon;
}


function approximatelyEqualAbsRel(a, b, relEpsilon, absEpsilon) {
    if (Math.abs(a - b) <= absEpsilon)
        return true;

    return approximatelyEqualRel(a, b, relEpsilon);
}

console.log(approximatelyEqualAbsRel(-0.000123, 0, 0.01, 0.001)); // true
