
/**
 * Задача Longest Common Subsequence
 * Задача схоже на Longest Common Substring
 * Потрібно знайти найдовшу послідовність, яка є підпослідовністю обох S1 і S2
 * 
 * Що таке підпослідовність?
 * Підпослідовність утворюється з вихідної послідовності шляхом видалення нуля
 * або більше символів, без зміни порядку решти символів.
 * 
 * Приклад
 * Якщо S1 ="ABCDE"
 * Підпослідовності S1: "ACE", "ABD", "BDE", "C", "ABCDE" 
 * Але "AED" не є підпослідовністю, бо порядок символів 'A', 'E', 'D' у вихідному
 * слові порушений ('E' йде після 'D').
 * 
 * Тобто у слів "математика" і "кінематика" найдовшою спільним підпослідовністю буде "ематика", а для
 * "математика" і "галактика" - "атика"
 * 
 * Для fosh і fish найдовша subsequence буде 3 символи fsh
 * 
 * 
 * Це важлива задача бо схоже рішення використовується у відстані Левенштейна для пошуку мінімальної
 * кількості замін в одному слові щоб утворилося інше. Це потрібно при автокопліті чи автовиправленні слів, або
 * при неточному пошуку.
 * 
 * Також це дуже потужний інструмент для пошуку відповіді на питання наскільки одна сутність (файл, рядок і т.п)
 * схоже на іншу. Припустимо є два файли і вони ідентичні але у першому на початку є додатковий порожній рядок, 
 * тож файли однакові, різниця лише у 1 додатковому рядку, але якщо будемо порівнювати рядок за рядком то матимемо
 * 100% не співпадінь через різницю в 1 рядок. А через subsequence можна сказати що файли на 99% однакові
 */

/**
 * Дуже схожа на longestCommonSubstring за тим виключенням що
 * додається рядок dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
 */
function longestCommonSubsequence(original_word, compared_word) {
  const dp = new Array(original_word.length + 1)
  .fill(0)
  .map(() => new Array(compared_word.length + 1).fill(0))

  // потрібне тільки для наочності, це не є частиною алгоритму
  const letters = []
  letters.length = Math.max(original_word.length, compared_word.length)

  for(let i=1; i < dp.length; i++) {
    const current_char = original_word[i-1]
    for(j=1; j< dp[i].length; j++) {
      if(current_char == compared_word[j-1]) {
        dp[i][j] = dp[i-1][j-1] + 1
        letters[j-1] = current_char
      } else {
        dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1])
      }
    }
  }


  console.log(dp)
  console.log(letters)
}

// longestCommonSubsequence("hish", "fish")
// longestCommonSubsequence("hish", "vista")
longestCommonSubsequence("fosh", "fish")



/**
 * Маємо original_word fish і hish 
 * Спочатку заповнюємо всю матрицю нулями і також в алгоритму додаю рядок і колонку з нулями,
 * але тут для простоти не додаю їх (вони потрібні щоб у першого рядка можна було піти на 1 рядок назад,
 * і так само у кожного першого символу нового рядка можна було піти на 1 крок вліво).
 * 
 * Важлива відмінність Longest Common Subsequence від Longest Common Substring - це те, що якщо літери не співпадають,
 * то ми не лишаємо 0, як було у Longest Common Substring, а заповнюємо найбільшим числом з двох комірок - одна верхня і одна ліва
 * 
 * 
 *        f  o  s  h
 *    f   1  1  1  1      
 *    i   1  1  1  1  
 *    s   1  1  2  2
 *    h   1  1  2  3
 *    
 * У "f" є співпадіння по літерам тож ставимо 1 + значення з комірки на 1 комірку вверх і
 * 1 вліво (по діагоналі вліво вверх) - це 0 (бо її немає).
 * Далі маючи за основу літеру "f" ідемо до другого рядку з літерою "o". "f" не співпадає з "o", тому ми беремо
 * найбільше значення між коміркою зверху (0 - бо її немає) і коміркою зліва (це 1), і найбільше тут 1,
 * тож це значення і ставимо. За тією самою логікою і рухаємося далі
 * ....
 * Далі у "s" є співпадіння, тож так само ставимо 1 + найбільше значення з комірки зверху або зліва, вони обидві по 1,
 * тож маємо 1 + 1 = 2, тож записуємо 2.
 * ...
 * Далі у "h" є співапдіння, тож ставимо 1 + найбільше значення з комірки зверху або зліва, вони обидві по 2,
 * тож маємо 1 + 2 = 3, тож записуємо 3.
 * 
 * Тож для fosh і fish найбільший subsequence - це 3 символи (fsh)
 * 
 * 
 */