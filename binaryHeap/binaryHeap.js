
/**
 * Binary heaps дуже схожі на binary search tree, але мають кілька відмінностей
 * 
 * У MaxBinaryHeap parent nodes завжди більші ніж child nodes (батько більший за дитину)
 * У MinBinaryHeap навпаки parent nodes завжди менші ніж child nodes (дитина більша за батька)
 * 
 * Приклад для MaxBinaryHeap
 * 
 *            41
 *          /    \
 *        39      33
 *      /   \    /
 *     18   27  12
 *    
 * 
 *                100
 *              /     \
 *            19       36
 *          /   \     /  \
 *         17    3   25   1
 *        /  \
 *       2    7
 * 
 *  Тут добре видно що 25 більше за 19, але це не важливо, бо правило що parent має бути більше за child, а 36 > 25
 * 
 * 
 * Приклад для MinBinaryHeap
 * 
 *              1
 *           /     \
 *          7       4
 *        /  \    /   \
 *       22   8  100   6
 * 
 * 
 * 
 * 
 * Як представити binary heap у вигляді масиву і повернути назад при потребі
 * 
 *     100
 *      |
 *      -----------
 *         |      |
 *         19     36
 *         |      |
 *         |       -------------------
 *          -------------     |      |
 *                |     |     25     5
 *                17    12    |      |
 *                |     |     |       ----------------------
 *                |     |     --------------------    |     |   
 *                |     ---------------     |    |    1     4
 *                -----------   |     |     13   8
 *                    |     |   6     11
 *                    9    15
 * 
 * 
 *  [ 100, 19, 36, 17, 12, 25, 5, 9, 15, 6, 11, 13, 8, 1, 4 ]
 *     0    1   2   3   4   5  6  7  8   9  10  11  12 13 14
 *  
 *  Для n-ного індексу left child визначається за формулою: 2n + 1
 *  Для n-ного індексу right child визначається за формулою: 2n + 2
 * 
 *  Візьмемо 1 індекс - 19 ->
 *  left child:  2*1 + 1 = 3 index => 17
 *  right child: 2*1 + 2 = 4 index => 12
 * 
 * 
 *  Візьмемо 5 індекс - 25 ->
 *  left child:  2*5 + 1 = 11 index => 13
 *  right child: 2*5 + 2 = 12 index => 8                  
 * 
 * 
 *  Щоб з будь-якого child (і лівого і правого) отримати parent скористаємося формулою: Math.floor( (n - 1) / 2 )
 *  Визначимо parent для індексу 9 => число 6
 *  parent: (9 - 1) / 2 = 4 => число 12
 *  
 *  Визначимо parent для індексу 10 => число 11
 *  parent: (10 - 1) / 2 = 4.5 => Math.floor(4.5) = 4 => число 12
 * 
 * 
 * 
 * 
 * maxBinaryHeap/minBinaryHeap може бути використаний для priority queue
 * Приклад додавання задач у чергу з maxBinaryHeap. На верху у нас зажди найпріоритетніша, а як тільки ми її видалимо то друга за пріоритетністю стане на її місце
 *          
 *        неважлива задача              середньо важлива задача                 важлива задача                 важлива задача
 *                                          /                                   /            \                  /            \
 *                                   неважлива задача               середньо важлива задача          середньо важлива задача    неважлива задача
 *                                                                        /                                    /
 *                                                                   неважлива задача                   неважлива задача
 * 
 * 
 * 
 * 
 * 
 * 
 *    BIG O (time complexity)
 *    
 *    Insert - O(log n)
 *    Remove - O(log n)
 *    Search - O(n)
 * 
 * */