/**
 * GRAPH
 * 
 * Терміни:
 * 1. Vertex - вершина (теж саме що і node)
 * 2. Edge - лінія що з'єднує два Vertex (node)
 * 3. Weighted/Unweighted graph - Edge може мати вагу або не мати вагу
 *  
 *  Unweighted                    Weighted
 * 
 *                                    17
 *  A ------ B                    A ------ B
 *  |                           5 |
 *  C                             C
 * 
 * 
 * 4. Directed/Undirected graph - граф може бути направлений (кожна node вказує шлях яким можна рухатися), 
 * або не не направлений (можна рухатися як хочеш)
 *  
 * Directed 
 *    B
 *    ^   
 *    |     
 *    A <------> C
 * 
 * В цьому графі я можу піти від A до B, але не від B до A. З A можу піти до C, і навпаки з C і до A
 * 
 * Undirected
 *    B--D
 *    | /   
 *    A ------ C
 * В цьому графі я можу піти від A до B, і від B до A. З A можу піти до C, і навпаки з C і до A.
 * Валідні шляхи для мого undirected graph:
 * A -> C
 * A -> D
 * A -> B
 * 
 * B -> D
 * B -> A
 * 
 * D -> B
 * D -> A
 * 
 * C -> A
 * 
 * 
 * 
 * 
 * Як представити граф у програмуванні, є 2 способи, Adjacency Matrix і Adjacency List 
 * 
 * Adjacency Matrix - це представлення у вигляді матриці
 * 
 *    B--D
 *    | /   
 *    A ------ C
 * 
 *      - A B C D
 *      A 0 1 1 1
 *      B 1 0 0 1
 *      C 1 0 0 0
 *      D 1 1 0 0     
 * 
 * Там де стоїть 1 значить є edge між цими vertex (node), до прикладу A і B мають edge, тож для них стоїть 1,
 * а от C і B не мають спільної edge, тому для них стоїть 0
 * 
 * Потенційний недолік такого - дуже великі матриці, якщо у мене граф із 1000 vertex то я матиму матрицю 1000x1000 => 1_000_000 елементів
 * 
 * 
 * Adjacency List
 * Представимо наді vertex замість літер цифрами
 * 
 *    1--2
 *    | /   
 *    0 ------ 3 
 * 
 * 
 *           [
 *  index 0    [1, 2, 3],
 *  index 1    [2, 0],
 *  index 2    [1, 0],
 *  index 3    [0],
 *           ]
 * 
 * 
 *   Щоб дізнатися з чим має зв'язок vertex (node) 0 то ми звернемося до 0 індексу і це буде vertex: 1, 2, 3.
 *   Так само що дізнатися з чим пов'язаний vertex 3 звернемося до індексу 3, і отримаємо що він пов'язаний з vertex 0
 * 
 * 
 *  Або замість масиву використовувати hash table
 * 
 *    B--D
 *    | /   
 *    A ------ C 
 * 
 *   {
 *     A: ["B", "D", "C"],
 *     B: ["D", "A"],
 *     C: ["A"],
 *     D: ["B", "A"]
 *   }
 * 
 * 
 * 
 * 
 * 
 * 
 * BIG O
 * |E| - number of edges
 * |V| - number of vertices
 * 
 * | Operation     |  Adjacency List  |  Adjacency Matrix   |
 * |---------------|------------------|---------------------|
 * | Add Vertex    |  O(1)            |   O(|V^2|)          |
 * |---------------|------------------|---------------------|
 * | Add Edge      |  O(1)            |   O(1)              |
 * |---------------|------------------|---------------------|
 * | Remove Vertex |  O(|V| + |E|)    |   O(|V^2|)          |
 * |---------------|------------------|---------------------|
 * | Remove Edge   |  O(|E|)          |   O(1)              |
 * |---------------|------------------|---------------------|
 * | Query         |  O(|V| + |E|)    |   O(1)              |
 * |---------------|------------------|---------------------|
 * | Storage       |  O(|V| + |E|)    |   O(|V^2|)          |
 * |---------------|------------------|---------------------|
 * 
 * 
 * Add Vertex для Matrix O(|V^2|) бо коли ми додамо 1 елемент (не важливо скільки у нього edge) ми додаємо новий рядок і колонку в матрицю,
 * тобто матриця збільшиться по горизонталі і вертикалі на V (кількість Vertex(node))
 * 
 * Remove Vertex для Matrix, те саме як і з додаванням, при видаленні треба буде для кожної колонки (яких V) видалити елемент масиву і змістити
 * весь масив (довжина масиву теж V)
 * 
 * Remove Vertex для List ?
 * 
 * 
 * Remove Edge для Matrix O(1) бо якщо ми знаємо індекси на яких стоять Vertex у матриці (наприклад по горизонталі A - 0, по вертикалі D - 1), тоді
 * matrix[1][0] = 0
 * 
 * Remove Edge для List O(|E|) бо якщо ми хочемо видалити Edge між A і B то початку в A пройдемося по всім Edge і видалимо B, а потім
 * у B пройдемося по всім Edge і видалимо A
 * 
 * 
 * Query для Matrix O(1), так сама логіка як і при Remove Edge (наприклад по горизонталі A - 0, по вертикалі D - 1), тоді
 * matrix[1][0] елемент який шукали
 * 
 * Query для List O(|V| + |E|) ?
 * 
 * 
 * 
 * Загалом
 * Matrix:
 *  - займає більше пам'яті
 *  - повільно пройтися по всім edge?
 *  - швидко знайде конкретний edge
 * 
 * List:
 *  - займає менше пам'яті
 *  - швидко пройтися по всім edge?
 *  - повільно знайде конкретний edge
 * 
 * 
 * В більшості випадків vertex (нода) не має дуже багато edge, а тому доцільніше використовувати Adjacency List
 * Adjacency Matrix я гаю варто використовувати коли кожна нода пов'язана з усіма іншими нодами, або з дуже великою кількістю
 */