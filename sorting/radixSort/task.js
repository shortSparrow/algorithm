
/**
 * Задача
 * Дано масив рядків, де різні рядки мають різне число символів, але загальне
 * число символів у всіх рядках становить п. Покажіть, як упорядкувати рядки за час O(n).
 * 
 * (Зверніть увагу, що тут потрібен стандартний порядок за абеткою, наприклад (a < ab < b.)
 * 
 */



/**
 * В цьому рішенні ми розбиваємо масив на комірки, але не один раз, а рекурсивно
 * Нехай буде масив ["a", "aaa", "ab", "b", "ba", "bb", "c"]
 * При першій ітерації
 *    ["a", "aaa", "ab"] потрапить в один кошик
 *    ["b", "ba", "bb"] потрапить в другий кошик
 *    ["c"] потрапить в третій кошик
 * 
 *      Далі починаючи з першого елемента кошика запускається розбиття на кошики знову
 *       ["a"] потрапить в один кошик
 *       ["aaa"] потрапить в другий кошик
 *       ["ab"] потрапить в третій кошик
 *      
 *            Далі починаючи з першого елемента кошика запускається розбиття на кошики знову
 *             Оскільки ["a"] це лише один елемент у масиві то він і повернеться
 *             Оскільки ["aaa"] це лише один елемент у масиві то він і повернеться
 *             Оскільки ["ab"] це лише один елемент у масиві то він і повернеться
 * 
 * 
 *      Переходимо до ["b", "ba", "bb"]
 *        ["b"] потрапить в один кошик
 *        ["ba"] потрапить в другий кошик
 *        ["bb"] потрапить в третій кошик    
 *  
 *             Далі починаючи з першого елемента кошика запускається розбиття на кошики знову
 *              Оскільки ["b"] це лише один елемент у масиві то він і повернеться
 *              Оскільки ["ba"] це лише один елемент у масиві то він і повернеться
 *              Оскільки ["bb"] це лише один елемент у масиві то він і повернеться
 * 
 *       Переходимо до ["c"] 
 *          ["c"] потрапить в один кошик
 *  
 *              Далі починаючи з першого елемента кошика запускається розбиття на кошики знову
 *              Оскільки ["c"] це лише один елемент у масиві то він і повернеться
 * 
 * Цей алгоритм нагадує CountingSort, але CountingSort працює по одному розряду, а ту ми розкидуємо числа
 * по комірках по всіх розрядах (від меншого на першій ітерації до останнього на останній), тому цей алгоритм
 * більше відноситься до radix
 * 
 * Оскільки тут MSD тому що ми ідемо від більшого розряду до меншого, ми починаємо з d=0
 * і тут перший розряд і є найбільш вагомим (ab стоїть перед b)
 */

// Основна функція MSD Radix Sort
function msdRadixSort(arr, d = 0) {
    if (arr.length <= 1) {
        return arr;
    }
    
    // Розбиваємо масив на "кошики" за поточним символом 'd'
    // charCodeAt(d) може повернути значення від 0 до 65535, але для 
    // української + англійської + цифр все має вкластися у діапазон 0...255
    const buckets = new Array(256).fill(0).map(() => []);

    // Поділ на підмасиви
    for (const str of arr) {
        // Якщо рядок коротший, кладемо його в спеціальний "нульовий" кошик
        const charCode = (d < str.length) ? str.charCodeAt(d) + 1 : 0;
        buckets[charCode].push(str);
    }

    // Рекурсивне сортування
    let result = [];
    for (let i = 0; i < buckets.length; i++) {
        const bucket = buckets[i];
        if (bucket.length > 0) {
            // Рекурсивний виклик для кожного кошика
            const sortedBucket = msdRadixSort(bucket, d + 1);
            result.push(...sortedBucket);
        }
    }

    return result;
}

// Приклад використання:
const strings = ["a", "ab", "aaa", "c", "b", "bb", "ba"];
console.log("Відсортований масив:", msdRadixSort(strings));
// Очікуваний результат: ["a", "aaa", "ab", "b", "ba", "bb", "c"]