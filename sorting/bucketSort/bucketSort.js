/**
 * Коміркове сортування (bucket sort)
 *
 * Коміркове сортування (сортування комірками, bucket sort) припускає, що входові дані
 * мають рівномірний розподіл; час роботи цього алгоритму у середньому випадку становить O(n).
 * 
 * Поточна реалізація BucketSort працює лише з числами в межах [0,1), тобто з дробовими числами від 0 до 1
 * Взагалі BucketSort не обов'язково має працювати в діапазоні [0,1), але на ньому його ефективність
 * дуже висока O(n). 
 * Головна умова: щоб Bucket Sort був ефективним, дані повинні бути розподілені більш-менш рівномірно
 * 
 * 
 * Принцип роботи:
 *    - Створення кошиків: Створюється масив buckets, довжина якого = довжині вхідного масиву
 * 
 *    - Розподіл: Кожен лемент з вхідного масиву масштабується від 0 до n (оскільки вхідні дані
 *                знаходяться в межах від 0 до 1) і далі це масштабоване число потрапляє у buckets на 
 *                індекс який дорівнює його значенню (якщо масштабоване число = 8 то воно потрапить на індекс 8)
 * 
 *    - Сортування: Вміст кожного кошика сортується окремо за допомогою іншого алгоритму
 *                  (зазвичай це Insertion Sort або Quick Sort).
 * 
 *    - Об'єднання: Відсортовані кошики об'єднуються в один фінальний масив.
 * 
 * 
 *  
 * Часова складність
 *    1. Найкращий та середній випадок: O(n)
 *    Основна умова: Щоб досягти цієї складності, вхідні дані мають бути рівномірно розподілені
 *    по кошиках. Це означає, що кількість елементів у кожному кошику буде приблизно однаковою
 *    (наприклад, n/k, де n — кількість елементів, а k — кількість кошиків.
 *     Наприклад 100 елементів і 10 кошиків => 100/10 = 10 отже в кожному кошику має бути +- 10 елементів.
 *     АЛЕ ми беремо k=n тож у нас в середньому має бути 1 елемент в одному кошику, і саме тому insertion Sort
 *     відпрацює за O(1) для цього випадку, ну а якщо якийсь кошик міститиме 2 елементи то це не проблема)
 *  
 *    Розподіл елементів: Перша фаза — розподіл n елементів по кошиках — вимагає одного проходу по масиву, що має складність O(n).
 *    
 *    Сортування кошиків: У цьому випадку кожен кошик містить невелику, константну кількість елементів.
 *    Якщо ми використовуємо Insertion Sort (який має складність O(m^2) для масиву з m елементів), 
 *    то сортування кожного з k кошиків буде дуже швидким: k⋅O((n/k)^2). При великих n це зводиться до O(n).
 *    Оскільки k у нас дорівнює n
 *    
 *    Об'єднання: Об'єднання відсортованих кошиків також є лінійною операцією O(n).
 *    
 *    Отже, загальна середня складність становить O(n) + O(n) + O(n) = O(n).
 *    Це робить Bucket Sort надзвичайно швидким для відповідних наборів даних.
 * 
 * 
 *    2. Найгірший випадок: O(n²)
 *    Найгірший випадок трапляється, коли всі елементи потрапляють в один і той же кошик. Це може статися, якщо дані
 *    нерівномірно розподілені або якщо функція, яка визначає кошик для елемента, не є ефективною.
 * 
 *    Коли ми застосовуємо допоміжний алгоритм сортування (наприклад, Insertion Sort) до цього "переповненого" кошика,
 *    його складність стає O(n²), що і визначає загальну складність алгоритму.
 * 
 *    Цей сценарій робить Bucket Sort набагато менш ефективним, ніж алгоритми, засновані на порівняннях, такі як Merge Sort
 *    або Quick Sort, у найгіршому випадку.
 * 
 * 
 * 
 * Просторова складність: O(n+k)
 *        n — кількість елементів у вхідному масиві.
 *        k — кількість кошиків.
 * 
 * 
 * 
 * ЦІКАВИЙ АСПЕКТ АЛГОРИТМУ
 * 
 * Навіть якщо входові дані розподілені нерівномірно, коміркове сортування
 * може працювати за лінійний час. Допоки входові дані мають таку властивість, що
 * сума квадратів розмірів комірок лінійна відносно загальної кількості елементів, з
 * рівності випливає лінійний час виконання коміркового сортування.
 * 
 * Пояснення "лінійності"
 * Алгоритм Bucket Sort складається з двох основних етапів:
 *    - Розподіл елементів по кошиках. Це завжди займає лінійний час — O(n), бо ми просто проходимося по всіх елементах один раз.
 * 
 *    - Сортування елементів всередині кожного кошика. Ось тут і ховається вся "магія".
 *      Якщо ми використовуємо, наприклад, сортування вставками для кожного кошика, час сортування одного кошика з n елементами 
 *      становить O(ni^2) (i -мається на увазі і-тий елемент). Загальний час для сортування всіх кошиків — це сума часу для кожного кошика:
 *          T=O(n1^2 + n2^2 +...+ nk^2), де k — кількість кошиків.
 * 
 * Тож фраза "Допоки входові дані мають таку властивість, що сума квадратів розмірів комірок лінійна відносно загальної
 * кількості елементів, з рівності випливає лінійний час виконання коміркового сортування" говорить, що
 * якщо ця сума n1^2 + n2^2 +...+ nk^2 виявляється лінійною відносно n (тобто O(n)), то весь алгоритм буде працювати за лінійний час.
 * 
 * 
 */

const {insertionSort} = require('../insertionSort/insertionSort')

function bucketSort(arr) {
  const n = arr.length
  const buckets = new Array(n).fill(0).map(() => []);
  const result = []

  /**
   * Нехай вхідний масив [0.3, 0.4, 0.31, 0.1, 0.51, 0.55] 
   * На виході маємо [[0.1], [0.3, 0.31], [0.4], [0.51, 0.55]]
   * 
   * bucketIndex = Math.floor(n * arr[i])
   * Це є ключовою частиною розподілу чисел в межах [0,1) по кошиках.
   * Ми множимо число arr[i] на n, щоб масштабувати його від діапазону [0,1) до довжини масиву n
   * Таким чином всі значення будуть на межі від 0 до n і потравлять у відповідні індекси у масиві
   * 
   */
  for (let i = 0; i < arr.length; i++) {
    const bucketIndex = Math.floor(n * arr[i]);
    buckets[bucketIndex].push(arr[i]);
  }

  
  for (let i = 0; i < buckets.length; i++) {
    insertionSort(buckets[i])
  }


  for (let i=0; i<buckets.length; i++) {
    result.push(...buckets[i]);
  }
  
  return result
}

console.log(bucketSort([0.3, 0.4, 0.31, 0.1, 0.51, 0.55]));

