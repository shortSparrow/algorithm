/**
 * Counting Sort
 * 
 * Counting Sort - працює лише для цілих чисел
 * Його основна ідея складається з таких кроків:
 *    - Знаходимо найбільше число у вхідному масиві (k)
 * 
 *    - Створюємо новий масив, довжина якого = k і заповнюємо його 0
 * 
 *    - Проходимося циклом по вхідному масиву і кожен його елемент ми 'ставимо' 
 *      на індекс, який вповідає знаменню елемента (якщо елемент 5 - 'ставимо' його на індекс 5).
 *      Але ми не ставимо його фактично, ми просто знаємо, що елемент зі значенням 5 буде стояти на
 *      індексі 5, а ставимо ми саме кількість таких елементів. 
 *      Тобто якщо у вхідному масиву три 5 то в після проходу по всьому циклу матимемо що на індексі 5
 *      буде стояти 3. І це означає що є 3 елементи 5 у вхідному масиві
 * 
 *    - Видозмінюємо новостворений масив, так щоб тепер у ньому була не просто кількість елементів,
 *      а інформація про те де який елемент починається і де закінчується.
 *      Нехай новостворений масив буде 
 *          [2, 0, 2, 3, 0, 1] (2 нулі, 0 одиниць, 2 двійки, 3 трійки, 0 четвірок, 1 п'ятірка)
 *      Ми пройдемося по ньому циклом і для першого елемента (оскільки на індексі 0 - то значить елемент 0)
 *      ми знаємо що він починається з позиції 1 (фактичний індекс 0) і закінчується на позиції 2 (фактичний індекс 1).
 *      Тобто перший нуль піде на позицію 1, а другий на позицію 2.
 *      
 *      Ідемо до другого елементу (індекс 1, отже це елемент 1), таких елементів немає, тому ідемо далі.
 *      
 *      Ідемо до третього елементу (індекс 2, а отже елемент 2). Ми знаємо що зараз у нас зайняті тільки
 *      дві позиції, тому перша 2 піде на позицію 3 (фактичний індекс 2), а друга на позицію 4 (фактичний індекс 3).
 *      
 *      Ідемо до четвертого елементу (індекс 3, а отже елемент 3). Ми знаємо що зараз у нас зайняті позиції з 1 до 4,
 *      а отже перша трійка іде на позицію 5 (фактичний індекс 4), друга на позицію 6 (фактичний індекс 5), а
 *      третя на позицію 7 (фактичний індекс 6).
 *      
 *      Ідемо до п'ятого елементу (індекс 4, отже елемент 4), таких немає.
 * 
 *      Ідемо до шостого елементу (індекс 6, отже елемент 6). Зараз у нас зайняті позиції з 1 до 7, тому
 *      ставимо елемент на позицію 8 (фактичний індекс 7)
 *    
 *  І все, після цих кроків маємо відсортований масив
 * 
 * 
 * Важлива особливість такого сортування що воно стійке
 * Це означає, що числа з однаковими значеннями значенням покріплять у кінцевий результат
 * у тому ж порядку у якому вони були у вхідному масиві.
 * Така властивість може бути дуже корисною коли із сортованим елементом переносяться супутні дані
 * 
 * 
 * Складність такого алгоритму O(n+k), де 
 *    n - довжина вхідного масиву
 *    k - найбільше число у вхідному масиві
 * Відповідно такий алгоритм найбільш ефективний коли k менше за n або близьке до нього
 * Якщо у нас n = 10, а k = 10_000_000_000 то відповідно ми створимо масив у 10_000_000_000 і будемо по
 * ньому ітеруватися
 * 
 * 
 */


function countingSort(inputArr) {
  const maxValue = Math.max(...inputArr);
  const countArray = new Array(maxValue + 1).fill(0);
  const responseArray = new Array(inputArr.length)

  /**
   * Ставимо елементи на індекси які відповідають їхнім значення 
   * і показуємо скіпки який елемент зустрічається
   * Для вхідного масиву [2, 5, 3, 0, 2, 3, 0, 3]
   * Результат буде [2, 0, 2, 3, 0, 1] (2 нулі, 0 одиниць, 2 двійки, 3 трійки, 0 четвірок, 1 п'ятірка)
   */ 
  
  for (let i = 0; i < inputArr.length; i++) {
    countArray[inputArr[i]] += 1;
  }


  /**
   * Нехай countArray = [2, 0, 2, 3, 0, 1]
   * Зараз ми знаємо скільки у нас наприклад двійок, але ми не знаємо де
   * вони починаються і де закінчуються
   * Якщо 0 у нас дві штуки то вони почнуться з позиції 1 (індекс 0) і закінчаться на позиції 2 (індекс 1)
   * Далі іде 1 якої у нас немає
   * Потім іде 2 якої дві штуки тож вона має початися з позиції 3 (індекс 2) і закінчаться на позиції 4 (індекс 3)
   * 
   * На виході маємо [2, 2, 4, 7, 7, 8]
   * Тепер подивимося на на елемент 4 - це індекс 2 тож він відповідає за число 2, і зараз це означає, що
   * у нас буде чотири елементи які менші або дорівнюють 2. Тобто остання двійка буде
   * на четвертій позиції (або на 3 індексі)
   * 
   * countArray[i - 1] - це по суті додавання інформації скільки попередніх позицій зайнято.
   * Оскільки елемент вже розставлені там у порядку зростання то дивлячись на попередній я знаю його позицію,
   * знаю на якій позиції він закінчиться, і тому можу додати це значення до свого поточного елементу і таким чином
   * передам наступному елемент інформацію де закінчується поточний
   *  
   * До змін:    [0,3,1] (0 нулів, 3 одиниці, 1 двійка)
   * Після змін: [0,3,4] (нулів немає, одиниці починаються на позиції 1 і закінчується на позиції 3, 
   *                      двійка починається і закінчується на позиції 4)
   * Фактичний результат: [1,1,1,2] - це вже відповідь яка робиться у наступному циклі
   * 
   * До змін:    [1,3,1] (1 нуль, 3 одиниці, 1 двійка)
   * Після змін: [1,4,5] -> (нуль починається і закінчується на позиції 1, одиниці починаються на 
   *                         позиції 2 і закінчується на позиції 4, двійка починається і закінчується на позиції 5)
   * Фактичний результат: [0,1,1,1,2] - це вже відповідь яка робиться у наступному циклі
   * 
   */
  for (let i = 1; i <= maxValue; i++) {
    countArray[i] = countArray[i] + countArray[i - 1];
  }

  /**
   * Маючи інформацію де який елемент починається і де закінчується ми розставляємо їх у кінцевий масив
   */

  for (let i = inputArr.length - 1; i >= 0; i--) {
    let val = inputArr[i] // Поточний елемент з оригінального масиву
    let newPosition = countArray[val] - 1 // у countArray вказано позиції, а не індекси, тому -1 перетворить їх на індекси
    responseArray[newPosition] = val
    countArray[val]-- // Зменшуємо значення, на цей індекс вже поставили, оскільки ми рухаємося з кінця масиву то -1 покаже на яку настану позицію треба ставити наступне таке саме число (якщо воно буде)

  }

  return responseArray
}

console.log(countingSort([2, 5, 3, 0, 2, 3, 0, 3]));
