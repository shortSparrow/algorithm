import hashlib

# Задача
# У нас є база даних з username юзерів, коли новий користувач хоче зареєструватися
# йому потрібно вигадати новий унікальний username. Як нам швидко перевірити чи цей 
# username вільний, особливо якщо у нас дуже багато юзерів і лінійний пошук займе забагато часу

# Bloom Filter
# Це імовірнісний (probabilistic) алгоритм який дає False Positive результат
# Це означає що якщо я перевірю чи є username "senya1" у базі даних і мені повернеться
# результат True, то це означає що його може і не бути у базі даних. АЛЕ якщо цього
# username немає, мені НІКОЛИ не повернеться інформація що він є 
# 
# Bloom Filter можна замінити на звичайний hash table, але коли у тебе купа даних, 
# припустимо сторінки які індексує google, то це трильйони сайтів і тоді стає важливим питання
# пам'яті, а оскільки Bloom Filter використовує саме бітовий масив то елементів можна
# записати дуже багато



# ! Важливе уточнення. Bloom Filter працює з бітовим масивом для економії пам'яті, але тут
# ! ми використовуємо звичайний масив з int для простоти, суть та саме, але треба знати різницю
# ! що масив з int 0 і 1 - це не бітовий масив!

# Вибір кількості хеш-функцій (k) і розміру бітового масиву (m) є ключовим для ефективності фільтра Блума.
# 
# Скільки різних хеш-функцій (k) потрібно використовувати?
# Потенційний недолік: "чим більше хеш-функцій, то тим більше значень ми заповнимо для
# одного елемента і тоді вийде, що різні елементи можуть перекрити один одного швидше", а
# це в свою чергу збільшить ймовірність хибнопозитивного спрацювання. 
#  
# З іншого боку, якщо k занадто мале будуть часто з'являтися колізії, що знову ж таки
# збільшить ймовірність хибнопозитивного спрацювання.
# 
# Існує оптимальна кількість хеш-функцій k, яка мінімізує ймовірність хибнопозитивного спрацювання 
# для заданого розміру масиву m та очікуваної кількості елементів n
# *Оптимальне значення k розраховується за формулою: k=(m/n)∗ln(2)
#     k – оптимальна кількість хеш-функцій.
#     m – розмір бітового масиву (кількість бітів).
#     n – очікувана кількість елементів, які будуть додані до фільтра.
#     ln(2) – натуральний логарифм 2 (приблизно 0.693).
# 



MAX_LENGTH = 10
hashed_database = [0] * MAX_LENGTH
def add(value: str):
    h1 = hashlib.sha256(f"{value}".encode('utf-8')).hexdigest()
    h2 = hashlib.sha1(f"{value}".encode('utf-8')).hexdigest()
    h1 = int(h1, 16)
    h2 = int(h2, 16)

    hashed_database[h1%MAX_LENGTH] = 1
    hashed_database[h2%MAX_LENGTH] = 1

def check(value):
    h1 = hashlib.sha256(f"{value}".encode('utf-8')).hexdigest()
    h2 = hashlib.sha1(f"{value}".encode('utf-8')).hexdigest()
    h1 = int(h1, 16)
    h2 = int(h2, 16)

    if hashed_database[h1%MAX_LENGTH] == 1 and hashed_database[h2%MAX_LENGTH] == 1:
      return True
    else:
        return False

# add("Hello") # Заповнить 1 індекси 0 і 9
# add("Bloom") # Заповнить 1 індекси 2 і 7
# На цей момент hashed_database має такий вигляд [1, 0, 1, 0, 0, 0, 0, 1, 0, 1]

# print(check("Hello"))
# print(check("Bloom"))

# h1 поверне індекс 8, h2 поверне індекс 2
# Але оскільки тільки один з індексів дорівнює 1, то значить цього username немає в нашій базі даних
# print(check("Welcome")) 