from sklearn.cluster import KMeans
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt # Для відображення зображень

"""
Задача
Застосувати алгоритм KMeans щоб зменшити кількість кольорів у зображенні

Пояснення алгоритму
Зображення має широту і висоту - 640х427, це означає, що воно містить 427 рядків і 640 колонок,
якщо розглядати його як двомірний масив, а сумарно це 273280 пікселів, або елементів масиву.
[
  [[r,g,b],[r,g,b],[r,g,b],[r,g,b]...],
  [[r,g,b],[r,g,b],[r,g,b],[r,g,b]...],
  [[r,g,b],[r,g,b],[r,g,b],[r,g,b]...],
  ...
]

KMeans працює з двомірними масивами, тому розкладаємо зображення в двомірний масив
[[r,g,b],[r,g,b],[r,g,b],[r,g,b],[r,g,b],[r,g,b],[r,g,b],[r,g,b]...]


Далі це заноситься в сам KMeans
KMeans має отримати набір даних (pixels), і кількість центроїдів (k - скільки кольорів ми хочемо мати на виході)

KMeans генерує k центроїдів (точок тієї є розмірності що і дані, які передали, тобто для нас це [r,g,b], і що
важливо центроїди в своїх значеннях обмежені максимальним і мінімальним значенням для нас це від 0 до 255).
Тобто KMeans генерує k точок які в просторі який ми передали, і це є кольори, тож маємо 12 рівномірно
розподілених кольорів

Далі KMeans починає проходитися по всім pixel і визначати до якого центроїда конкретно цей піксель ближче.
Коли це визначено то створюється новий масив labels і в нього записується index центроїда до якого піксель найближче.
Тож ми матимемо labels який по довжині такий самий як і pixels і вони 'мають' зв'язок, n-ний елемент pixels
посилається на n-ний елемент labels і навпаки, бо індекси центроїдів до labels додавали в такій саме послідовності
як і pixels (ми проходилися по масиву pixels і пушили індекс центроїда до labels)

Далі ми проходимося циклом по масиву центроїдів і для кожного центроїда дістаємо всі пікселі з pixels, які відносяться
до цього центроїда, це робиться за допомогою labels. З labels можна дізнатися який індекс в pixels відноситься до якого центроїда.
Це робиться для того щоб порахувати середній колір кожного центроїда. Ми дістали всі пікселі, які
відносяться до поточного центроїда і сумуємо їх red колір, потім green, потім blue, а потім кожен з цих кольорів ділимо на
загальну кількість пікселів що відносяться до цього центроїда і так отримаємо середній колір.

Тепер записуємо нові кольори центроїдів - це наші нові центроїди

Тепер повторюємо все спочатку, проходимося циклом по кожному пікселю, визначаємо до якого (вже нового) центроїда він ближче,
запсуємо індекс центроїда у labels і т.п.


З приводу визначення який центроїд ближче до пікселя.
Тут використовується норма L2 - теорема Піфагора (math.sqrt( (r1-r2)^2 + (g1-g2)^2 + (g1-g2)^2 ))


Важливо зауважити що бібліотека працює на порядок швидше, для зображення ./cat.jpg бібліотека повертає зображення
за 10-15 секунд, в той час як моє самописне рішення поверне десь хвилин 10-15 або більше (1 ітерація займає до 2хв).
Основна причина, що в самописному рішенні я проходжуся циклом по pixels, в середині нього по масиву з 12 центроїдів
і в ньому визначаю який до якого центроїда ближче піксель. Тож маємо складність M*N = 273280 * 12 = 3279360 для
однієї ітерації, а таких ітерацій може бути 12-15. Це основне місце де у мене затримка по часу.
А бібліотека KMeans робить Векторизацію (Vectorization), вона на машинному рівні не шукає по одному до якого центроїда
піксель ближче, вона робить це для всіх одночасно, це значно заощаджує час

"""

# --- Крок 1: Перетворення зображення на масив пікселів для K-Means ---
image_path = './cat.jpg'
original_image = Image.open(image_path)
print(f"Оригінальний розмір зображення: {original_image.size}")

# --- Крок 2: Перетворення зображення на масив пікселів для K-Means ---
# Спочатку перетворимо зображення на масив NumPy
# original_image.convert('RGB') гарантує, що зображення буде в форматі RGB,
# навіть якщо воно було в іншому (наприклад, RGBA з прозорістю).
converted = original_image.convert('RGB')
image_np = np.array(converted)

# Ми знаємо, що наше зображення має розміри (висота, ширина, 3 канали RGB).
# Для k-means нам потрібен список "точок", де кожна точка - це колір пікселя (R, G, B).
# Тому ми "розгортаємо" масив: перетворюємо його з 3D (висота x ширина x 3)
# на 2D (кількість_пікселів x 3).
# Кількість пікселів = висота * ширина. Кожен рядок буде виглядати [R, G, B].
height, width, _ = image_np.shape
pixels = image_np.reshape(-1, 3) # -1 автоматично розраховує кількість рядків


# --- Крок 3: Застосування K-Means ---
# Визначаємо бажану кількість кольорів (k)
n_colors = 12 # Бажана кількість - це 12

# Ініціалізуємо модель KMeans.
# n_init='auto' - дозволяє sklearn автоматично визначати кількість запусків з різними ініціалізаціями.
# random_state - забезпечує відтворюваність результатів.
kmeans = KMeans(n_clusters=n_colors, n_init='auto', random_state=42)

# Fit вказує KMeans знайти n_colors кластерів серед наших даних (пікселів)
kmeans.fit(pixels)

# Отримуємо кольори центроїдів. Це і є наші нові, узагальнені кольори!
# Кожен центроїд - це [R, G, B] значення.
new_colors = kmeans.cluster_centers_.astype(int)

# Отримуємо мітки кластерів для кожного пікселя.
# Це масив, де для кожного оригінального пікселя вказано, до якого кластера (0 до n_colors-1) він належить.
labels = kmeans.labels_

# --- Крок 4: Перефарбування зображення ---
# Створюємо новий масив для зображення з квантованими кольорами
# Ми використовуємо мітки (labels), щоб для кожного пікселя знайти відповідний новий_колір
#
# labels - це масив індексів, який містить значення від 0 до n_colors, тобто у нас від 0 до 11, і
# його довжина = довжині pixels [[0],[8], [11], [3]... ]. Тобто це говорить що pixels[1] - відноситься
# до центроїда на індексі 8 (всього центроїдів 12 - це наші n_colors).
# Тож тепер new_colors[labels] "поєднає" new_colors і labels і зробить так щоб new_colors[labels] був набором
# пікселів з лише 12 кольорами.
# .reshape(image_np.shape) зробить щоб new_colors[labels] який є двомірним масивом з rgb перетворився у
# тримірний, як оригінальне зображення де є рядки і колонки в яких rgb 
quantized_image_np = new_colors[labels].reshape(image_np.shape)

# Перетворюємо NumPy масив назад в об'єкт Image
quantized_image = Image.fromarray(quantized_image_np.astype(np.uint8), 'RGB')


# --- Крок 5: Відображення оригінального та квантованого зображення ---
plt.figure(figsize=(12, 6))

plt.subplot(1, 2, 1) # 1 рядок, 2 колонки, 1-й графік
plt.imshow(original_image)
plt.title("Оригінальне зображення")
plt.axis('off')

plt.subplot(1, 2, 2) # 1 рядок, 2 колонки, 2-й графік
plt.imshow(quantized_image)
plt.title(f"Квантоване зображення ({n_colors} кольорів)")
plt.axis('off')

plt.tight_layout() # Автоматично налаштовує відступи
plt.show()

# --- Збереження квантованого зображення (за бажанням) ---
output_path = 'quantized_image.jpg' # Назва файлу для збереження
quantized_image.save(output_path)