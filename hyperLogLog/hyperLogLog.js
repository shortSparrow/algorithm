
/**
 * HyperLogLog
 * 
 * Призначення: Дозволяє отримати  кількість унікальних елементів у множині
 *              використовуючи дуже мало пам'яті
 * 
 * Уявіть, що вам потрібно порахувати кількість унікальних відвідувачів веб-сайту за день,
 * де кожен візит — це окремий запис. Якщо відвідувачів мільйони або навіть мільярди, зберігання
 * кожного унікального ідентифікатора для підрахунку стає надзвичайно витратним з точки зору пам'яті.
 * Саме для таких завдань і був створений алгоритм HyperLogLog — елегантний імовірнісний підхід, що
 * дозволяє отримати напрочуд точну оцінку кількості унікальних елементів, використовуючи при цьому
 * мізерний обсяг пам'яті.
 * 
 * 
 * Нотатка розділена на 3 головні частини:
 *    I ЗАГАЛЬНА ІНФОРМАЦІЯ ПРО ТЕОРІЮ ІМОВІРНОСТЕЙ
 *    II ЯК ПРАЦЮЄ АЛГОРИТМ HyperLogLog
 *    III ЧОМУ АЛГОРИТМ HyperLogLog ПРАЦЮЄ?
 * 
 * 
 * 
 * ------ I ЗАГАЛЬНА ІНФОРМАЦІЯ ПРО ТЕОРІЮ ІМОВІРНОСТЕЙ ------ 
 * 
 * ------ МАТЕМАТИЧНА БАЗА 1 ------
 * Розглянемо приклад з монеткою, припустимо я кидаю монетку 2 рази, які можливі
 * комбінації я можу отримати:
 *  Герб Герб
 *  Герб Цифра
 *  Цифра Герб
 *  Цифра Цифра
 * Тобто всього 4 комбінації. І імовірність кожної з них 1/4
 * Тож можна записати формулу для визначення загальної кількості комбінації
 * 2^n, де 2 це можливі варіанти Герб або Цифра, а n - кількість кидків
 * А імовірність кожної з комбінації буде 1/(2^n)
 * 
 * Розгляньмо це на бітах для простоти
 * Припустимо маю 3 біти, тож 2^3 = 8, отже 8 різних комбінації
 *    000
 *    001
 *    010
 *    011
 *    100
 *    101
 *    110
 *    111
 * І імовірність кожного з них 1/8
 * 
 * 
 * ------ МАТЕМАТИЧНА БАЗА 2 ------
 * А тепер розгляньмо інший випадок, припустимо я маю дві послідовності по 1 біту
 *    X -> 0 1
 *    X -> 0 1
 * Кожна із цих двох послідовностей має імовірність 1/2 щоб утворити якусь комбінацію,
 * але питання, яка імовірність що обидві утворять комбінацію 0
 * Для цього перемножимо їх імовірності 1/2 * 1/2 = 1/4. Це доволі просто зрозуміти, адже
 * маємо всього 4 комбінації і лише 1 з них буде 00
 *  
 * Теж саме для послідовності по 2 біти
 *    XX -> 00 01 10 11
 *    XX -> 00 01 10 11
 * Імовірність отримати комбінацію 00 00 буде 1/4 * 1/4 = 1/16
 * 
 * А яка імовірність що хоча одна комбінація з XX XX буде 00?
 * 
 * Ймовірність, що перша комбінація НЕ буде '00': 3/4
 * Ймовірність, що друга комбінація НЕ буде '00': 3/4
 * Ймовірність, що ЖОДНА з комбінацій НЕ буде '00' 3/4 * 3/4 = 9/16
 * Ймовірність, що ХОЧА Б ОДНА комбінація буде '00': 1 - 9/16 = 16/16 - 9/16 = 7/16 = 0.43
 * АБО другий спосіб порахувати
 * Подія "хоча б одна '00'" може відбутися трьома способами:
 *  Перша комбінація '00', а друга НЕ '00' -> 1/4 * 3/4 = 3/16
 *  Перша комбінація НЕ '00', а друга '00' -> 3/4 * 1/4 = 3/16
 *  Обидві комбінації '00' (00,00) -> 1/4 * 1/4 = 1/16
 *  Просумуємо всі варіанти отримати хоча б одну комбінацію 3/16 + 3/16 + 1/16 = 7/16 = 0.43 
 * 
 * 
 * ------ МАТЕМАТИЧНА БАЗА 3 ------
 * Припустимо я кидаю монетку 6 разів яка імовірність отримати результат 3 Герби (0) і 3 Цифри (1)?
 * X 0 1
 * X 0 1
 * X 0 1
 * X 0 1
 * X 0 1
 * X 0 1
 * 
 * Усього різних комбінацій може бути 64, отже імовірність кожної 1/64, але цікавинка в тому, що
 * 3 Герби (0) і 3 Цифри (1) ми можемо отримати різними способами
 * 
 * Імовірність отримати 1 Герб (0) і 5 Цифр (1)
 * 011111
 * 101111
 * 110111
 * 111011
 * 111101
 * 111110
 * Кількість способів 6, отже імовірність отримати 1 Герб і 5 Цифр = 6/64
 * 
 * Імовірність отримати 2 Герби (0) і 4 Цифри (1)
 * 001111
 * 010111
 * 011011
 * 011101
 * 011110
 * 100111
 * 101011
 * 101101
 * 101110
 * 110011
 * 110101
 * 110110
 * 111001
 * 111010
 * 111100
 * Кількість способів 15, отже імовірність отримати 2 Герби і 5 Цифр = 15/64
 * 
 * Імовірність отримати 3 Герби (0) і 3 Цифри (1)
 * 000111
 * 001011
 * 001101
 * 001110
 * 010011
 * 010101
 * 010110
 * 011001
 * 011010
 * 011100
 * 100011
 * 100101
 * 100110
 * 101001
 * 101010
 * 101100
 * 110001
 * 110010
 * 110100
 * 111000
 * Кількість способів 20, отже імовірність отримати 3 Герби і 3 Цифри = 20/64
 * 
 * Імовірність отримати 4 Герби (0) і 2 Цифри (1) така сама як і 2 Герби (0) і 4 Цифри (1) = 15/64
 * 
 * Імовірність отримати 5 Гербів (0) і 1 Цифру (1) така сама як і 1 Герб (0) і 5 Цифр (1) = 6/64
 * 
 * Для того щоб отримати кількість варіантів є формула
 * n!/(k!*(n-k)!)
 * n - кількість кидків (випробувань)
 * k - кількість успіхів (гербів)
 * Для варіанту 2 герби і 4 цифри з 6 кидків
 * 6!/(2!*(6-2)!) = 6!/(2!*4!) = 720/48 = 15
 * 
 * 
 * З приводу 3 герби і 3 цифри можна також розглянути це на законі великих чисел, нехай у нас буде
 * 1000 кидків, яка імовірність 500 гербів і 500 цифр (не обов'язково послідовно, а в будь-які послідовності)?
 * За законом великих чисел імовірність буде близька до 50%. Бо варіантів якими можна отримати такі комбінації
 * набагато більше ніж комбінацію 990 гербів і 10 цифр
 * 
 * 
 * 
 * 
 * ------ II ЯК ПРАЦЮЄ АЛГОРИТМ HyperLogLog ------
 * Ми маємо якийсь набір елементів
 * 
 * Крок 1: Хешування
 * Кожен елемент, який ми хочемо порахувати (наприклад, IP-адреса відвідувача або його унікальний ідентифікатор),
 * пропускається через хеш-функцію. Ця функція перетворює вхідні дані у фіксований рядок бітів (наприклад, 32 або 64 біти),
 * який виглядає як випадкова послідовність нулів та одиниць. Важливо, щоб хеш-функція розподіляла значення рівномірно.
 * Приклад:
 *    елемент_A -> 1101010010101101...
 *    елемент_B -> 0010110101100101...
 *    елемент_C -> 0000101101010011...
 * 
 * Крок 2: Розбиття на "кошики" (регістри)
 * Щоб підвищити точність, HyperLogLog не покладається на одну-єдину оцінку. Замість цього він використовує тисячі
 * маленьких оцінювачів, які називаються регістрами або "кошиками".
 * 
 * Бінарний хеш-код кожного елемента ділиться на дві частини:
 *    Перша частина (наприклад, перші 10 бітів) використовується для визначення, в який із кошиків потрапить цей елемент.
 *    Якщо ми використовуємо 10 бітів, то у нас буде 2^10 = 1024 кошики.
 * 
 *    Друга частина (решта бітів) використовується для підрахунку кількості нулів на початку
 * 
 * Приклад:
 *    Припустимо, ми маємо хеш 00110101... і використовуємо перші 2 біти для вибору кошика. 00 вказує на кошик №0.
 *    Якби було 01 то це був би кошик №1, а якщо 10 - то кошик №3, і відповідно 11 - кошик №4
 * 
 * 
 * Крок 3: Підрахунок початкових нулів і оновлення регістрів
 * Для другої частини хешу алгоритм рахує кількість нулів на початку.
 * 
 * Приклад:
 *    Для елемента з хешем 00001011... кількість початкових нулів — 4.
 * 
 * Кожен кошик (регістр) зберігає максимальну кількість початкових нулів, яку він коли-небудь
 * бачив для елементів, що до нього потрапили. Якщо в кошик №5 приходить елемент, і кількість початкових
 * нулів у його хеші більша за ту, що вже зберігається в цьому кошику, значення в кошику оновлюється.
 * Якщо менша або така ж — нічого не відбувається.
 * 
 * 
 * Крок 4: Оцінка результату за допомогою гармонійного середнього
 * Після обробки всіх елементів ми маємо масив кошиків, кожен з яких містить максимальну кількість
 * початкових нулів, що спостерігалася.
 * Просто усереднити ці значення було б не дуже точно через можливі викиди (дуже великі або дуже малі
 * значення в деяких кошиках). Тому HyperLogLog використовує гармонійне середнє, яке є більш стійким до таких викидів
 * 
 * 
 * Наочний приклад алгоритму
 * Уявімо, що у нас є лише 4 кошики (m=4). Наші регістри на початку порожні (заповнені нулями): [0, 0, 0, 0].
 * 
 * 1. Приходить елемент "user123":
 *    Хешуємо: hash("user123") -> 01 00101... (пробіл для наочності).
 *    Перші 2 біти (01) вказують на кошик №1.
 *    Решта (00101...) має 2 початкові нулі.
 *    Регістр №1 тепер max(0, 2) = 2. Наші регістри: [0, 2, 0, 0].
 * 
 * 2. Приходить елемент "user456":
 *    Хешуємо: hash("user456") -> 11 01101...
 *    Перші 2 біти (11) вказують на кошик №3.
 *    Решта (01101...) має 1 початковий нуль.
 *    Регістр №3 тепер max(0, 1) = 1. Регістри: [0, 2, 0, 1].
 * 
 * 3. Приходить елемент "user789":
 *    Хешуємо: hash("user789") -> 01 00011...
 *    Перші 2 біти (01) вказують на Кошик №1.
 *    Решта (00011...) має 3 початкові нулі.
 *    Регістр №1 тепер max(2, 3) = 3. Регістри: [0, 3, 0, 1]
 * 
 * 4. Приходить знову "user123":
 *    Його хеш такий самий. Він знову потрапить у кошик №1, але кількість початкових нулів (2) не більша
 *    за поточне значення (3), тому нічого не зміниться.
 * 
 * 
 * Після обробки всіх даних у нас є масив кошиків [0, 3, 0, 1] для фінального розрахунку за формулою гармонійного середнього
 * Тут використовується не звичайне гармонійне середнє, а (сума 2^-Mj)
 * Гармонійне середнє = 2^-3 + 2^-1 = 0.625
 * І тепер відповідь буде (alpha_m * кількість_регістрів^2) / Гармонійне середнє
 * alpha_m - це спеціальне значення, яке має різні значення в залежності від кількості регістрів, нехай у нас буде 0.673
 * 0.673 * 4^2 / 0.625 = 17
 * У нас вийшло 17, а не 3, бо кількість елементів дуже маленька. Для дуже маленької кількості, або дуже великої
 * вводять додаткові обробки їх можна подивитися у ./hyperLogLogAdvanced.js
 * 
 * 
 * 
 * 
 * 
 * ------ III ЧОМУ АЛГОРИТМ HyperLogLog ПРАЦЮЄ? ------
 * В основі hyperLogLog лежить фундаментальний принцип теорії ймовірностей:
 *    Якщо ви спостерігаєте дуже рідкісну подію, ймовірно, ви провели дуже багато спроб.
 * 
 * У контексті HyperLogLog (та його попередників, таких як LogLog), нас цікавить не просто
 * будь-яка послідовність бітів, а саме початкова кількість нулів. Це не тому, що нулі "особливі",
 * а тому, що вони є зручним маркером для ілюстрації рідкісності події. Замість нулів можна було
 * б використати будь яку іншу комбінацію, просто з нулями простіше для розуміння і простіше їх рахувати
 * 
 * 1. Хеш-функція як генератор випадковості
 * Тепер розглянемо початок такого випадкового бітового рядка:
 *    Ймовірність того, що хеш починається з 0, дорівнює 1/2
 *    Ймовірність того, що він починається з 00, дорівнює 1/2 * 1/2 = 1/4
 *    Ймовірність того, що він починається з 000, дорівнює 1/2 * 1/2 * 1/2 = 1/8
 *    Ймовірність того, що хеш починається з k нулів, дорівнює (1/2)^k
 * Як бачите, чим довша послідовність нулів, тим експоненційно рідкіснішою є така подія.
 * 
 * Ми замість 000 можемо взяти 111 або будь яку іншу комбінацію, наприклад 100 бо імовірність кожної з них 1/8
 * Але тут треба розуміти різницю, і важливо як саме ми це читаємо.
 * Яка імовірність що всі три біти заповнені 0 - 1/8
 * Яка імовірність що два біти з трьох заповнені 0 - 3/8
 *  Ось тут велика відмінність бо це може бути як 100 так і 001 або 010, бо я не питаю саме за
 *  якусь конкретну комбінацію, я питаю за кількість 0 в трьох бітах, і імовірність цього 3/8.
 *  А от кожна з комбінацій 100, 001, 010 буде мати імовірність 1/8
 * 
 * Тож треба сказати що рідкісність комбінації дає те, що комбінацію з трьох 0 отримати менш імовірно,
 * ніж комбінацію з двох 0 і однієї 1.
 * 
 * 2. Зв'язок між рідкістю події та кількістю спроб
 * Якщо ви хочете знайти хеш, що починається хоча б з одного 0, вам в середньому знадобиться 2 унікальні елементи.
 * Якщо ви хочете знайти хеш, що починається з 00, вам в середньому знадобиться 4 унікальні елементи.
 * Якщо ви хочете знайти хеш, що починається з 00000 (5 нулів), вам в середньому знадобиться 2^5=32 унікальні елементи.
 * 
 * Ця "довжина початкової послідовності нулів" є тим, що HLL використовує як статистичний сигнал.
 * Якщо хеш-функція дійсно рівномірно розподілена, то ймовірність того, що ми побачимо довгий префікс
 * нулів, обернено пропорційна до кількості таких хешів, які ми маємо. Тобто, чим більше унікальних елементів
 * ми хешуємо, тим більша ймовірність того, що хоча б один з них матиме дуже довгу послідовність початкових нулів.
 * 
 * Максимальна кількість початкових нулів, яку ми зустріли (k), говорить нам про
 * порядок величини загальної кількості унікальних елементів (N). Якщо ми обробили N різних елементів
 * і найрідкісніша подія, яку ми бачили, — це k початкових нулів, то можна зробити обґрунтоване припущення,
 * що N приблизно дорівнює 2^k
 * 
 * 
 * 
 * 3. Проблема "удачі" та її вирішення "кошиками"
 * Добре, але що, якщо нам просто пощастило? Що, як другий елемент, який ми побачили, випадково мав хеш,
 * що починається з 10 нулів? Алгоритм би вирішив, що у нас тисячі елементів, хоча насправді їх лише два."
 * 
 * І саме тут з'являється геніальність HyperLogLog — використання багатьох "кошиків" (регістрів).
 * Замість того, щоб проводити один великий експеримент, ми проводимо тисячі маленьких експериментів одночасно.
 * 
 * Уявіть, що ви хочете оцінити середній зріст людей у країні. Виміряти зріст лише однієї, найвищої людини, яку ви
 * знайшли, — погана ідея. Натомість ви створюєте 1000 груп людей, знаходите найвищу людину в кожній групі, а потім
 * усереднюєте ці результати. Такий підхід дасть набагато стабільнішу і точнішу оцінку.
 * 
 * HyperLogLog робить те саме:
 *    Він ділить усі унікальні елементи на тисячі груп (кошиків) на основі першої частини їхнього хешу.
 *    Для кожної групи він знаходить максимальну кількість початкових нулів (проводить свій "міні-експеримент").
 *    Потім він усереднює результати всіх цих тисяч експериментів (за допомогою гармонійного середнього, яке добре ігнорує викиди).
 * 
 * 
 */
